<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Leitor de Cart√£o-Resposta via C√¢mera</title>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<style>
    body { font-family: Arial; margin: 10px; }
    video, canvas { width: 100%; max-width: 100%; border-radius: 8px; }
    #result { white-space: pre; background: #111; color: #0f0; padding: 10px; border-radius: 8px; margin-top: 12px; }
</style>
</head>

<body>

<h2>üì∑ Leitura de Cart√£o-Resposta (C√¢mera)</h2>

<video id="video" autoplay playsinline></video>
<canvas id="canvas" style="display:none;"></canvas>

<div id="result">Aponte o cart√£o para iniciar...</div>

<script>
let video = document.getElementById("video");
let canvas = document.getElementById("canvas");
let ctx = canvas.getContext("2d");

async function startCamera(){
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment" }
        });
        video.srcObject = stream;
    } catch(e){
        alert("Erro ao acessar c√¢mera: " + e);
    }
}
startCamera();

// Aguarda carregamento do OpenCV
cv['onRuntimeInitialized'] = () => {
    console.log("OpenCV carregado!");
    startScanner();
};

function startScanner(){
    setInterval(processFrame, 300); // l√™ a cada 300ms
}

function processFrame(){
    if (!video.videoWidth) return;

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    ctx.drawImage(video, 0, 0);

    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

    // blur + bordas
    let blur = new cv.Mat();
    cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);

    let edged = new cv.Mat();
    cv.Canny(blur, edged, 50, 150);

    // achar contornos
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edged, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let biggest = null;
    let maxArea = 0;

    for (let i = 0; i < contours.size(); i++){
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);

        if (area < 20000) continue;

        let peri = cv.arcLength(cnt, true);
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

        // procuramos um ret√¢ngulo (4 pontos)
        if (approx.rows === 4 && area > maxArea){
            maxArea = area;
            biggest = approx;
        }
    }

    if (!biggest){
        showResult("Procure enquadrar o cart√£o inteiro...");
        cleanup();
        return;
    }

    // warpPerspective ‚Üí deixa o cart√£o plano
    let warped = warpCard(src, biggest);

    // agora l√™ as bolhas do cart√£o alinhado
    let respostas = readBubbles(warped);

    showResult(JSON.stringify(respostas, null, 2));

    src.delete(); gray.delete(); blur.delete(); edged.delete();
    contours.delete(); hierarchy.delete();
}

function warpCard(src, points){
    // ordenar pontos (top-left, top-right, bottom-right, bottom-left)
    let pts = [];
    for(let i=0;i<4;i++){
        pts.push({x: points.intPtr(i,0)[0], y: points.intPtr(i,0)[1]});
    }

    pts.sort((a,b)=>a.y-b.y);
    let top = pts.slice(0,2).sort((a,b)=>a.x-b.x);
    let bottom = pts.slice(2,4).sort((a,b)=>a.x-b.x);

    let tl = top[0], tr = top[1], bl = bottom[0], br = bottom[1];

    let w = 900, h = 1200; // tamanho padr√£o do cart√£o
    let dst = cv.Mat.zeros(h, w, cv.CV_8UC3);

    let srcTri = cv.matFromArray(4,1,cv.CV_32FC2,[tl.x,tl.y, tr.x,tr.y, br.x,br.y, bl.x,bl.y]);
    let dstTri = cv.matFromArray(4,1,cv.CV_32FC2,[0,0, w,0, w,h, 0,h]);

    let M = cv.getPerspectiveTransform(srcTri, dstTri);
    cv.warpPerspective(src, dst, M, new cv.Size(w,h));

    return dst;
}

// --- LER BOLHAS A/B/C/D ---
function readBubbles(img){
    let gray = new cv.Mat();
    cv.cvtColor(img, gray, cv.COLOR_RGBA2GRAY);

    let th = new cv.Mat();
    cv.threshold(gray, th, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

    let respostas = {};
    const QUESTOES = 40;
    const ALT = 4;

    // ajustes conforme o cart√£o
    let startX = img.cols * 0.12;
    let endX   = img.cols * 0.88;
    let startY = img.rows * 0.28;
    let endY   = img.rows * 0.90;

    let colWidth = (endX - startX) / 4;
    let rowHeight = (endY - startY) / (QUESTOES/4);

    let q = 1;

    for (let c=0; c<4; c++){
        for (let r=0; r<QUESTOES/4; r++){

            let baseX = startX + c * colWidth;
            let baseY = startY + r * rowHeight;

            let scores = [];

            for (let a=0; a<ALT; a++){
                let bx = baseX + a*(colWidth/4);
                let by = baseY + rowHeight*0.35;

                let roi = th.roi(new cv.Rect(bx, by, colWidth/4.5, rowHeight*0.55));
                scores.push(cv.countNonZero(roi));
                roi.delete();
            }

            let maxVal = Math.max(...scores);
            let idx = scores.indexOf(maxVal);

            if (maxVal < 200) respostas[q] = "‚Äî";
            else respostas[q] = ["A","B","C","D"][idx];

            q++;
        }
    }

    gray.delete(); th.delete();
    return respostas;
}

function showResult(txt){
    document.getElementById("result").textContent = txt;
}

function cleanup(){}
</script>

</body>
</html>
